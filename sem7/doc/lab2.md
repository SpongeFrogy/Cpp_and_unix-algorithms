# ЛР #2: Структуры данных и динамическое программирование

## Цель

Познакомить студента с основами структур данных и методикам динамического
программирования.

## Задача

Поиск оптимального (кратчайшего, быстрейшего или самого дешевого) пути,
проходящего через промежуточный пункты по одному разу и возвращающегося в
исходную точку. К примеру, нахождение наиболее выгодного маршрута, позволяющего
коммивояжеру посетить со своим товаром определенные города по одному разу и
вернуться обратно. Мерой выгодности маршрута может быть минимальная длина
пути.
Задать перечень точек с координатами X и Y. Пример:

- Точка 1, X1, Y1

- Точка 2, X2, Y2

- Точка 3, X3, Y3

- Точка ...

В качестве отправной и конечной точки брать первую введенную точку.

### 1

Спроектировать оптимальную структуру для решения задачи с точки зрения
затрат памяти. Реализовать на языке C++ или Python.

```python
class TriangularMatrix:
   def __init__(self, size: int) -> None:
      self.size = size
      self.matrix = [0.] * (size * (size + 1) // 2)

   def __setitem__(self, key: tuple[int, int], value) -> None:
      i, j = max(key), min(key)
      index = (i * (i + 1) // 2) + j
      self.matrix[index] = value
   
   def __getitem__(self, key: tuple[int, int]) -> None:
      i, j = max(key), min(key)
      index = (i * (i + 1) // 2) + j
      return self.matrix[index]
   
   def __str__(self) -> str:
      s = ""
      for i in range(self.size):
         for j in range(i):
            s+= str(self.__getitem__((i, j))) + ", "
         s+= str(self.__getitem__((i, i)))
         s += "\n"
      return s
   
   def __len__(self):
      return self.size
```

### 2

Спроектировать оптимальный алгоритм решения задачи с использованием
технологий динамического программирования. Оценить выислительные и
емкостные затраты. Реализовать на языке C++ или Python.

```python
def tsp_recursive(graph, visited, current_city, start_city, num_cities):
   if visited == (1 << num_cities) - 1:
      # If all cities are visited, return to the start city
      return graph[current_city][start_city], [current_city, start_city]
    
   min_tour_cost = sys.maxsize
   min_path = []

   for next_city in range(num_cities):
      if not visited & (1 << next_city):
         visited |= 1 << next_city
         tour_cost, path = tsp_recursive(graph, visited, next_city, start_city, num_cities)
         tour_cost += graph[current_city][next_city]
            
         if tour_cost < min_tour_cost:
            min_tour_cost = tour_cost
            min_path = [current_city] + path
            
         visited &= ~(1 << next_city)
    
   return min_tour_cost, min_path

def tsp(graph: list[list[float]]) -> tuple[float, list[int]]:
   num_cities = len(graph)
   start_city = 0
   visited = 1 << start_city
   min_tour_cost, min_path = tsp_recursive(graph, visited, start_city, start_city, num_cities)
    
   return min_tour_cost, min_path
```

## Вывод

Модифицированный рекурсивный алгоритм задачи коммивояжера (TSP) имеет экспоненциальную временную сложность, а именно O(n^2 * 2^n), где:

- n — количество городов.
- Фактор 2^n возникает из-за того, что существует 2^n возможных подмножеств городов, которые стоит посетить. Каждое подмножество представляет штат в рекурсивной функции, и для каждого состояния мы исследуем все возможные следующие города для посещения.

Эта экспоненциальная временная сложность делает алгоритм непрактичным для большого количества городов, поскольку он быстро становится дорогостоящим в вычислительном отношении. Для экземпляров TSP небольшого и среднего размера алгоритм может работать эффективно, но для более крупных экземпляров предпочтительны более эффективные алгоритмы, такие как динамическое программирование или эвристика, например алгоритм ближайшего соседа или алгоритм Кристофидеса.

В результате выполнения данной лабораторной работы мы изучили метод динамического программирования и его применение для решения задачи коммивояжера. Также мы научились разбивать задачу на более мелкие подзадачи и сохранять результаты для последующего использования. В целом, метод динамического программирования является очень эффективным способом решения сложных задач, и его знание может быть полезным в различных областях науки и техники.
